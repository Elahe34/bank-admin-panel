//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class Client {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }
n
    /**
     * @param scope (optional) 
     * @return OK
     */
    getAccsessToken(clientId: string, clientSecret: string, grantType: string, username: string, password: string, scope: string | undefined): Promise<ResultAccessTokenDtoResultDto> {
        let url_ = this.baseUrl + "/api/Authentication/GetAccsessToken?";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined and cannot be null.");
        else
            url_ += "ClientId=" + encodeURIComponent("" + clientId) + "&";
        if (clientSecret === undefined || clientSecret === null)
            throw new Error("The parameter 'clientSecret' must be defined and cannot be null.");
        else
            url_ += "ClientSecret=" + encodeURIComponent("" + clientSecret) + "&";
        if (grantType === undefined || grantType === null)
            throw new Error("The parameter 'grantType' must be defined and cannot be null.");
        else
            url_ += "GrantType=" + encodeURIComponent("" + grantType) + "&";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined and cannot be null.");
        else
            url_ += "Username=" + encodeURIComponent("" + username) + "&";
        if (password === undefined || password === null)
            throw new Error("The parameter 'password' must be defined and cannot be null.");
        else
            url_ += "Password=" + encodeURIComponent("" + password) + "&";
        if (scope === null)
            throw new Error("The parameter 'scope' cannot be null.");
        else if (scope !== undefined)
            url_ += "Scope=" + encodeURIComponent("" + scope) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAccsessToken(_response);
        });
    }

    protected processGetAccsessToken(response: Response): Promise<ResultAccessTokenDtoResultDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultAccessTokenDtoResultDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResultAccessTokenDtoResultDto>(null as any);
    }

    /**
     * @return OK
     */
    configurationGET(): Promise<void> {
        let url_ = this.baseUrl + "/configuration";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processConfigurationGET(_response);
        });
    }

    protected processConfigurationGET(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    configurationPOST(body: FileConfiguration | undefined): Promise<void> {
        let url_ = this.baseUrl + "/configuration";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processConfigurationPOST(_response);
        });
    }

    protected processConfigurationPOST(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    outputcache(region: string): Promise<void> {
        let url_ = this.baseUrl + "/outputcache/{region}";
        if (region === undefined || region === null)
            throw new Error("The parameter 'region' must be defined.");
        url_ = url_.replace("{region}", encodeURIComponent("" + region));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processOutputcache(_response);
        });
    }

    protected processOutputcache(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    getEndpoints(): Promise<void> {
        let url_ = this.baseUrl + "/api/SwaggerConfig/services/GetEndpoints";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEndpoints(_response);
        });
    }

    protected processGetEndpoints(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    add(body: SwaggerEndpointConfigAddModel | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/SwaggerConfig/services/AddEndpoint/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAdd(_response);
        });
    }

    protected processAdd(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    edit(body: SwaggerEndpointConfigEditModel | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/SwaggerConfig/services/EditEndpoint/Edit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEdit(_response);
        });
    }

    protected processEdit(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param key (optional) 
     * @return OK
     */
    deleteEndpoint(key: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/SwaggerConfig/services/DeleteEndpoint?";
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "key=" + encodeURIComponent("" + key) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteEndpoint(_response);
        });
    }

    protected processDeleteEndpoint(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param swaggerKey (optional) 
     * @return OK
     */
    deleteRouteFile(swaggerKey: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/SwaggerConfig/services/DeleteRouteFile?";
        if (swaggerKey === null)
            throw new Error("The parameter 'swaggerKey' cannot be null.");
        else if (swaggerKey !== undefined)
            url_ += "swaggerKey=" + encodeURIComponent("" + swaggerKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteRouteFile(_response);
        });
    }

    protected processDeleteRouteFile(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class AggregateRouteConfig implements IAggregateRouteConfig {
    routeKey?: string | undefined;
    parameter?: string | undefined;
    jsonPath?: string | undefined;

    constructor(data?: IAggregateRouteConfig) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.routeKey = _data["routeKey"];
            this.parameter = _data["parameter"];
            this.jsonPath = _data["jsonPath"];
        }
    }

    static fromJS(data: any): AggregateRouteConfig {
        data = typeof data === 'object' ? data : {};
        let result = new AggregateRouteConfig();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["routeKey"] = this.routeKey;
        data["parameter"] = this.parameter;
        data["jsonPath"] = this.jsonPath;
        return data;
    }
}

export interface IAggregateRouteConfig {
    routeKey?: string | undefined;
    parameter?: string | undefined;
    jsonPath?: string | undefined;
}

export class AuthenticationOptions implements IAuthenticationOptions {
    authenticationProviderKey?: string | undefined;
    allowedScopes?: string[] | undefined;

    constructor(data?: IAuthenticationOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.authenticationProviderKey = _data["authenticationProviderKey"];
            if (Array.isArray(_data["allowedScopes"])) {
                this.allowedScopes = [] as any;
                for (let item of _data["allowedScopes"])
                    this.allowedScopes!.push(item);
            }
        }
    }

    static fromJS(data: any): AuthenticationOptions {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticationOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authenticationProviderKey"] = this.authenticationProviderKey;
        if (Array.isArray(this.allowedScopes)) {
            data["allowedScopes"] = [];
            for (let item of this.allowedScopes)
                data["allowedScopes"].push(item);
        }
        return data;
    }
}

export interface IAuthenticationOptions {
    authenticationProviderKey?: string | undefined;
    allowedScopes?: string[] | undefined;
}

export class DownstreamHostAndPort implements IDownstreamHostAndPort {
    host?: string | undefined;
    port?: number | undefined;

    constructor(data?: IDownstreamHostAndPort) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.host = _data["host"];
            this.port = _data["port"];
        }
    }

    static fromJS(data: any): DownstreamHostAndPort {
        data = typeof data === 'object' ? data : {};
        let result = new DownstreamHostAndPort();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["host"] = this.host;
        data["port"] = this.port;
        return data;
    }
}

export interface IDownstreamHostAndPort {
    host?: string | undefined;
    port?: number | undefined;
}

export class EndpointConfig implements IEndpointConfig {
    name?: string | undefined;
    version?: string | undefined;
    url?: string | undefined;

    constructor(data?: IEndpointConfig) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.version = _data["version"];
            this.url = _data["url"];
        }
    }

    static fromJS(data: any): EndpointConfig {
        data = typeof data === 'object' ? data : {};
        let result = new EndpointConfig();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["version"] = this.version;
        data["url"] = this.url;
        return data;
    }
}

export interface IEndpointConfig {
    name?: string | undefined;
    version?: string | undefined;
    url?: string | undefined;
}

export class ErrorDto implements IErrorDto {
    code?: string | undefined;
    description?: string | undefined;

    constructor(data?: IErrorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): ErrorDto {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["description"] = this.description;
        return data;
    }
}

export interface IErrorDto {
    code?: string | undefined;
    description?: string | undefined;
}

export class FileAggregateRoute implements IFileAggregateRoute {
    routeKeys?: string[] | undefined;
    routeKeysConfig?: AggregateRouteConfig[] | undefined;
    upstreamPathTemplate?: string | undefined;
    upstreamHost?: string | undefined;
    routeIsCaseSensitive?: boolean;
    aggregator?: string | undefined;
    readonly upstreamHttpMethod?: string[] | undefined;
    upstreamHeaderTemplates?: { [key: string]: string; } | undefined;
    priority?: number;

    constructor(data?: IFileAggregateRoute) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["routeKeys"])) {
                this.routeKeys = [] as any;
                for (let item of _data["routeKeys"])
                    this.routeKeys!.push(item);
            }
            if (Array.isArray(_data["routeKeysConfig"])) {
                this.routeKeysConfig = [] as any;
                for (let item of _data["routeKeysConfig"])
                    this.routeKeysConfig!.push(AggregateRouteConfig.fromJS(item));
            }
            this.upstreamPathTemplate = _data["upstreamPathTemplate"];
            this.upstreamHost = _data["upstreamHost"];
            this.routeIsCaseSensitive = _data["routeIsCaseSensitive"];
            this.aggregator = _data["aggregator"];
            if (Array.isArray(_data["upstreamHttpMethod"])) {
                (<any>this).upstreamHttpMethod = [] as any;
                for (let item of _data["upstreamHttpMethod"])
                    (<any>this).upstreamHttpMethod!.push(item);
            }
            if (_data["upstreamHeaderTemplates"]) {
                this.upstreamHeaderTemplates = {} as any;
                for (let key in _data["upstreamHeaderTemplates"]) {
                    if (_data["upstreamHeaderTemplates"].hasOwnProperty(key))
                        (<any>this.upstreamHeaderTemplates)![key] = _data["upstreamHeaderTemplates"][key];
                }
            }
            this.priority = _data["priority"];
        }
    }

    static fromJS(data: any): FileAggregateRoute {
        data = typeof data === 'object' ? data : {};
        let result = new FileAggregateRoute();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.routeKeys)) {
            data["routeKeys"] = [];
            for (let item of this.routeKeys)
                data["routeKeys"].push(item);
        }
        if (Array.isArray(this.routeKeysConfig)) {
            data["routeKeysConfig"] = [];
            for (let item of this.routeKeysConfig)
                data["routeKeysConfig"].push(item.toJSON());
        }
        data["upstreamPathTemplate"] = this.upstreamPathTemplate;
        data["upstreamHost"] = this.upstreamHost;
        data["routeIsCaseSensitive"] = this.routeIsCaseSensitive;
        data["aggregator"] = this.aggregator;
        if (Array.isArray(this.upstreamHttpMethod)) {
            data["upstreamHttpMethod"] = [];
            for (let item of this.upstreamHttpMethod)
                data["upstreamHttpMethod"].push(item);
        }
        if (this.upstreamHeaderTemplates) {
            data["upstreamHeaderTemplates"] = {};
            for (let key in this.upstreamHeaderTemplates) {
                if (this.upstreamHeaderTemplates.hasOwnProperty(key))
                    (<any>data["upstreamHeaderTemplates"])[key] = (<any>this.upstreamHeaderTemplates)[key];
            }
        }
        data["priority"] = this.priority;
        return data;
    }
}

export interface IFileAggregateRoute {
    routeKeys?: string[] | undefined;
    routeKeysConfig?: AggregateRouteConfig[] | undefined;
    upstreamPathTemplate?: string | undefined;
    upstreamHost?: string | undefined;
    routeIsCaseSensitive?: boolean;
    aggregator?: string | undefined;
    upstreamHttpMethod?: string[] | undefined;
    upstreamHeaderTemplates?: { [key: string]: string; } | undefined;
    priority?: number;
}

export class FileAuthenticationOptions implements IFileAuthenticationOptions {
    allowedScopes?: string[] | undefined;
    authenticationProviderKey?: string | undefined;
    authenticationProviderKeys?: string[] | undefined;

    constructor(data?: IFileAuthenticationOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["allowedScopes"])) {
                this.allowedScopes = [] as any;
                for (let item of _data["allowedScopes"])
                    this.allowedScopes!.push(item);
            }
            this.authenticationProviderKey = _data["authenticationProviderKey"];
            if (Array.isArray(_data["authenticationProviderKeys"])) {
                this.authenticationProviderKeys = [] as any;
                for (let item of _data["authenticationProviderKeys"])
                    this.authenticationProviderKeys!.push(item);
            }
        }
    }

    static fromJS(data: any): FileAuthenticationOptions {
        data = typeof data === 'object' ? data : {};
        let result = new FileAuthenticationOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.allowedScopes)) {
            data["allowedScopes"] = [];
            for (let item of this.allowedScopes)
                data["allowedScopes"].push(item);
        }
        data["authenticationProviderKey"] = this.authenticationProviderKey;
        if (Array.isArray(this.authenticationProviderKeys)) {
            data["authenticationProviderKeys"] = [];
            for (let item of this.authenticationProviderKeys)
                data["authenticationProviderKeys"].push(item);
        }
        return data;
    }
}

export interface IFileAuthenticationOptions {
    allowedScopes?: string[] | undefined;
    authenticationProviderKey?: string | undefined;
    authenticationProviderKeys?: string[] | undefined;
}

export class FileCacheOptions implements IFileCacheOptions {
    ttlSeconds?: number | undefined;
    region?: string | undefined;
    header?: string | undefined;
    enableContentHashing?: boolean | undefined;

    constructor(data?: IFileCacheOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ttlSeconds = _data["ttlSeconds"];
            this.region = _data["region"];
            this.header = _data["header"];
            this.enableContentHashing = _data["enableContentHashing"];
        }
    }

    static fromJS(data: any): FileCacheOptions {
        data = typeof data === 'object' ? data : {};
        let result = new FileCacheOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ttlSeconds"] = this.ttlSeconds;
        data["region"] = this.region;
        data["header"] = this.header;
        data["enableContentHashing"] = this.enableContentHashing;
        return data;
    }
}

export interface IFileCacheOptions {
    ttlSeconds?: number | undefined;
    region?: string | undefined;
    header?: string | undefined;
    enableContentHashing?: boolean | undefined;
}

export class FileConfiguration implements IFileConfiguration {
    routes?: FileRoute[] | undefined;
    dynamicRoutes?: FileDynamicRoute[] | undefined;
    aggregates?: FileAggregateRoute[] | undefined;
    globalConfiguration?: FileGlobalConfiguration;

    constructor(data?: IFileConfiguration) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["routes"])) {
                this.routes = [] as any;
                for (let item of _data["routes"])
                    this.routes!.push(FileRoute.fromJS(item));
            }
            if (Array.isArray(_data["dynamicRoutes"])) {
                this.dynamicRoutes = [] as any;
                for (let item of _data["dynamicRoutes"])
                    this.dynamicRoutes!.push(FileDynamicRoute.fromJS(item));
            }
            if (Array.isArray(_data["aggregates"])) {
                this.aggregates = [] as any;
                for (let item of _data["aggregates"])
                    this.aggregates!.push(FileAggregateRoute.fromJS(item));
            }
            this.globalConfiguration = _data["globalConfiguration"] ? FileGlobalConfiguration.fromJS(_data["globalConfiguration"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FileConfiguration {
        data = typeof data === 'object' ? data : {};
        let result = new FileConfiguration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.routes)) {
            data["routes"] = [];
            for (let item of this.routes)
                data["routes"].push(item.toJSON());
        }
        if (Array.isArray(this.dynamicRoutes)) {
            data["dynamicRoutes"] = [];
            for (let item of this.dynamicRoutes)
                data["dynamicRoutes"].push(item.toJSON());
        }
        if (Array.isArray(this.aggregates)) {
            data["aggregates"] = [];
            for (let item of this.aggregates)
                data["aggregates"].push(item.toJSON());
        }
        data["globalConfiguration"] = this.globalConfiguration ? this.globalConfiguration.toJSON() : <any>undefined;
        return data;
    }
}

export interface IFileConfiguration {
    routes?: FileRoute[] | undefined;
    dynamicRoutes?: FileDynamicRoute[] | undefined;
    aggregates?: FileAggregateRoute[] | undefined;
    globalConfiguration?: FileGlobalConfiguration;
}

export class FileDynamicRoute implements IFileDynamicRoute {
    serviceName?: string | undefined;
    rateLimitRule?: FileRateLimitRule;
    downstreamHttpVersion?: string | undefined;
    downstreamHttpVersionPolicy?: string | undefined;
    metadata?: { [key: string]: string; } | undefined;

    constructor(data?: IFileDynamicRoute) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.serviceName = _data["serviceName"];
            this.rateLimitRule = _data["rateLimitRule"] ? FileRateLimitRule.fromJS(_data["rateLimitRule"]) : <any>undefined;
            this.downstreamHttpVersion = _data["downstreamHttpVersion"];
            this.downstreamHttpVersionPolicy = _data["downstreamHttpVersionPolicy"];
            if (_data["metadata"]) {
                this.metadata = {} as any;
                for (let key in _data["metadata"]) {
                    if (_data["metadata"].hasOwnProperty(key))
                        (<any>this.metadata)![key] = _data["metadata"][key];
                }
            }
        }
    }

    static fromJS(data: any): FileDynamicRoute {
        data = typeof data === 'object' ? data : {};
        let result = new FileDynamicRoute();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serviceName"] = this.serviceName;
        data["rateLimitRule"] = this.rateLimitRule ? this.rateLimitRule.toJSON() : <any>undefined;
        data["downstreamHttpVersion"] = this.downstreamHttpVersion;
        data["downstreamHttpVersionPolicy"] = this.downstreamHttpVersionPolicy;
        if (this.metadata) {
            data["metadata"] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key))
                    (<any>data["metadata"])[key] = (<any>this.metadata)[key];
            }
        }
        return data;
    }
}

export interface IFileDynamicRoute {
    serviceName?: string | undefined;
    rateLimitRule?: FileRateLimitRule;
    downstreamHttpVersion?: string | undefined;
    downstreamHttpVersionPolicy?: string | undefined;
    metadata?: { [key: string]: string; } | undefined;
}

export class FileGlobalConfiguration implements IFileGlobalConfiguration {
    requestIdKey?: string | undefined;
    serviceDiscoveryProvider?: FileServiceDiscoveryProvider;
    rateLimitOptions?: FileRateLimitOptions;
    qoSOptions?: FileQoSOptions;
    baseUrl?: string | undefined;
    loadBalancerOptions?: FileLoadBalancerOptions;
    downstreamScheme?: string | undefined;
    httpHandlerOptions?: FileHttpHandlerOptions;
    downstreamHttpVersion?: string | undefined;
    downstreamHttpVersionPolicy?: string | undefined;
    cacheOptions?: FileCacheOptions;
    metadataOptions?: FileMetadataOptions;

    constructor(data?: IFileGlobalConfiguration) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.requestIdKey = _data["requestIdKey"];
            this.serviceDiscoveryProvider = _data["serviceDiscoveryProvider"] ? FileServiceDiscoveryProvider.fromJS(_data["serviceDiscoveryProvider"]) : <any>undefined;
            this.rateLimitOptions = _data["rateLimitOptions"] ? FileRateLimitOptions.fromJS(_data["rateLimitOptions"]) : <any>undefined;
            this.qoSOptions = _data["qoSOptions"] ? FileQoSOptions.fromJS(_data["qoSOptions"]) : <any>undefined;
            this.baseUrl = _data["baseUrl"];
            this.loadBalancerOptions = _data["loadBalancerOptions"] ? FileLoadBalancerOptions.fromJS(_data["loadBalancerOptions"]) : <any>undefined;
            this.downstreamScheme = _data["downstreamScheme"];
            this.httpHandlerOptions = _data["httpHandlerOptions"] ? FileHttpHandlerOptions.fromJS(_data["httpHandlerOptions"]) : <any>undefined;
            this.downstreamHttpVersion = _data["downstreamHttpVersion"];
            this.downstreamHttpVersionPolicy = _data["downstreamHttpVersionPolicy"];
            this.cacheOptions = _data["cacheOptions"] ? FileCacheOptions.fromJS(_data["cacheOptions"]) : <any>undefined;
            this.metadataOptions = _data["metadataOptions"] ? FileMetadataOptions.fromJS(_data["metadataOptions"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FileGlobalConfiguration {
        data = typeof data === 'object' ? data : {};
        let result = new FileGlobalConfiguration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requestIdKey"] = this.requestIdKey;
        data["serviceDiscoveryProvider"] = this.serviceDiscoveryProvider ? this.serviceDiscoveryProvider.toJSON() : <any>undefined;
        data["rateLimitOptions"] = this.rateLimitOptions ? this.rateLimitOptions.toJSON() : <any>undefined;
        data["qoSOptions"] = this.qoSOptions ? this.qoSOptions.toJSON() : <any>undefined;
        data["baseUrl"] = this.baseUrl;
        data["loadBalancerOptions"] = this.loadBalancerOptions ? this.loadBalancerOptions.toJSON() : <any>undefined;
        data["downstreamScheme"] = this.downstreamScheme;
        data["httpHandlerOptions"] = this.httpHandlerOptions ? this.httpHandlerOptions.toJSON() : <any>undefined;
        data["downstreamHttpVersion"] = this.downstreamHttpVersion;
        data["downstreamHttpVersionPolicy"] = this.downstreamHttpVersionPolicy;
        data["cacheOptions"] = this.cacheOptions ? this.cacheOptions.toJSON() : <any>undefined;
        data["metadataOptions"] = this.metadataOptions ? this.metadataOptions.toJSON() : <any>undefined;
        return data;
    }
}

export interface IFileGlobalConfiguration {
    requestIdKey?: string | undefined;
    serviceDiscoveryProvider?: FileServiceDiscoveryProvider;
    rateLimitOptions?: FileRateLimitOptions;
    qoSOptions?: FileQoSOptions;
    baseUrl?: string | undefined;
    loadBalancerOptions?: FileLoadBalancerOptions;
    downstreamScheme?: string | undefined;
    httpHandlerOptions?: FileHttpHandlerOptions;
    downstreamHttpVersion?: string | undefined;
    downstreamHttpVersionPolicy?: string | undefined;
    cacheOptions?: FileCacheOptions;
    metadataOptions?: FileMetadataOptions;
}

export class FileHostAndPort implements IFileHostAndPort {
    host?: string | undefined;
    port?: number;

    constructor(data?: IFileHostAndPort) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.host = _data["host"];
            this.port = _data["port"];
        }
    }

    static fromJS(data: any): FileHostAndPort {
        data = typeof data === 'object' ? data : {};
        let result = new FileHostAndPort();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["host"] = this.host;
        data["port"] = this.port;
        return data;
    }
}

export interface IFileHostAndPort {
    host?: string | undefined;
    port?: number;
}

export class FileHttpHandlerOptions implements IFileHttpHandlerOptions {
    allowAutoRedirect?: boolean;
    maxConnectionsPerServer?: number;
    useCookieContainer?: boolean;
    useProxy?: boolean;
    useTracing?: boolean;
    pooledConnectionLifetimeSeconds?: number | undefined;

    constructor(data?: IFileHttpHandlerOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.allowAutoRedirect = _data["allowAutoRedirect"];
            this.maxConnectionsPerServer = _data["maxConnectionsPerServer"];
            this.useCookieContainer = _data["useCookieContainer"];
            this.useProxy = _data["useProxy"];
            this.useTracing = _data["useTracing"];
            this.pooledConnectionLifetimeSeconds = _data["pooledConnectionLifetimeSeconds"];
        }
    }

    static fromJS(data: any): FileHttpHandlerOptions {
        data = typeof data === 'object' ? data : {};
        let result = new FileHttpHandlerOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowAutoRedirect"] = this.allowAutoRedirect;
        data["maxConnectionsPerServer"] = this.maxConnectionsPerServer;
        data["useCookieContainer"] = this.useCookieContainer;
        data["useProxy"] = this.useProxy;
        data["useTracing"] = this.useTracing;
        data["pooledConnectionLifetimeSeconds"] = this.pooledConnectionLifetimeSeconds;
        return data;
    }
}

export interface IFileHttpHandlerOptions {
    allowAutoRedirect?: boolean;
    maxConnectionsPerServer?: number;
    useCookieContainer?: boolean;
    useProxy?: boolean;
    useTracing?: boolean;
    pooledConnectionLifetimeSeconds?: number | undefined;
}

export class FileLoadBalancerOptions implements IFileLoadBalancerOptions {
    expiry?: number;
    key?: string | undefined;
    type?: string | undefined;

    constructor(data?: IFileLoadBalancerOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.expiry = _data["expiry"];
            this.key = _data["key"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): FileLoadBalancerOptions {
        data = typeof data === 'object' ? data : {};
        let result = new FileLoadBalancerOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["expiry"] = this.expiry;
        data["key"] = this.key;
        data["type"] = this.type;
        return data;
    }
}

export interface IFileLoadBalancerOptions {
    expiry?: number;
    key?: string | undefined;
    type?: string | undefined;
}

export class FileMetadataOptions implements IFileMetadataOptions {
    metadata?: { [key: string]: string; } | undefined;
    separators?: string[] | undefined;
    trimChars?: string[] | undefined;
    stringSplitOption?: string | undefined;
    numberStyle?: string | undefined;
    currentCulture?: string | undefined;

    constructor(data?: IFileMetadataOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["metadata"]) {
                this.metadata = {} as any;
                for (let key in _data["metadata"]) {
                    if (_data["metadata"].hasOwnProperty(key))
                        (<any>this.metadata)![key] = _data["metadata"][key];
                }
            }
            if (Array.isArray(_data["separators"])) {
                this.separators = [] as any;
                for (let item of _data["separators"])
                    this.separators!.push(item);
            }
            if (Array.isArray(_data["trimChars"])) {
                this.trimChars = [] as any;
                for (let item of _data["trimChars"])
                    this.trimChars!.push(item);
            }
            this.stringSplitOption = _data["stringSplitOption"];
            this.numberStyle = _data["numberStyle"];
            this.currentCulture = _data["currentCulture"];
        }
    }

    static fromJS(data: any): FileMetadataOptions {
        data = typeof data === 'object' ? data : {};
        let result = new FileMetadataOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.metadata) {
            data["metadata"] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key))
                    (<any>data["metadata"])[key] = (<any>this.metadata)[key];
            }
        }
        if (Array.isArray(this.separators)) {
            data["separators"] = [];
            for (let item of this.separators)
                data["separators"].push(item);
        }
        if (Array.isArray(this.trimChars)) {
            data["trimChars"] = [];
            for (let item of this.trimChars)
                data["trimChars"].push(item);
        }
        data["stringSplitOption"] = this.stringSplitOption;
        data["numberStyle"] = this.numberStyle;
        data["currentCulture"] = this.currentCulture;
        return data;
    }
}

export interface IFileMetadataOptions {
    metadata?: { [key: string]: string; } | undefined;
    separators?: string[] | undefined;
    trimChars?: string[] | undefined;
    stringSplitOption?: string | undefined;
    numberStyle?: string | undefined;
    currentCulture?: string | undefined;
}

export class FileQoSOptions implements IFileQoSOptions {
    durationOfBreak?: number;
    exceptionsAllowedBeforeBreaking?: number;
    timeoutValue?: number;

    constructor(data?: IFileQoSOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.durationOfBreak = _data["durationOfBreak"];
            this.exceptionsAllowedBeforeBreaking = _data["exceptionsAllowedBeforeBreaking"];
            this.timeoutValue = _data["timeoutValue"];
        }
    }

    static fromJS(data: any): FileQoSOptions {
        data = typeof data === 'object' ? data : {};
        let result = new FileQoSOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["durationOfBreak"] = this.durationOfBreak;
        data["exceptionsAllowedBeforeBreaking"] = this.exceptionsAllowedBeforeBreaking;
        data["timeoutValue"] = this.timeoutValue;
        return data;
    }
}

export interface IFileQoSOptions {
    durationOfBreak?: number;
    exceptionsAllowedBeforeBreaking?: number;
    timeoutValue?: number;
}

export class FileRateLimitOptions implements IFileRateLimitOptions {
    clientIdHeader?: string | undefined;
    quotaExceededMessage?: string | undefined;
    rateLimitCounterPrefix?: string | undefined;
    disableRateLimitHeaders?: boolean;
    httpStatusCode?: number;

    constructor(data?: IFileRateLimitOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientIdHeader = _data["clientIdHeader"];
            this.quotaExceededMessage = _data["quotaExceededMessage"];
            this.rateLimitCounterPrefix = _data["rateLimitCounterPrefix"];
            this.disableRateLimitHeaders = _data["disableRateLimitHeaders"];
            this.httpStatusCode = _data["httpStatusCode"];
        }
    }

    static fromJS(data: any): FileRateLimitOptions {
        data = typeof data === 'object' ? data : {};
        let result = new FileRateLimitOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientIdHeader"] = this.clientIdHeader;
        data["quotaExceededMessage"] = this.quotaExceededMessage;
        data["rateLimitCounterPrefix"] = this.rateLimitCounterPrefix;
        data["disableRateLimitHeaders"] = this.disableRateLimitHeaders;
        data["httpStatusCode"] = this.httpStatusCode;
        return data;
    }
}

export interface IFileRateLimitOptions {
    clientIdHeader?: string | undefined;
    quotaExceededMessage?: string | undefined;
    rateLimitCounterPrefix?: string | undefined;
    disableRateLimitHeaders?: boolean;
    httpStatusCode?: number;
}

export class FileRateLimitRule implements IFileRateLimitRule {
    clientWhitelist?: string[] | undefined;
    enableRateLimiting?: boolean;
    period?: string | undefined;
    periodTimespan?: number;
    limit?: number;

    constructor(data?: IFileRateLimitRule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["clientWhitelist"])) {
                this.clientWhitelist = [] as any;
                for (let item of _data["clientWhitelist"])
                    this.clientWhitelist!.push(item);
            }
            this.enableRateLimiting = _data["enableRateLimiting"];
            this.period = _data["period"];
            this.periodTimespan = _data["periodTimespan"];
            this.limit = _data["limit"];
        }
    }

    static fromJS(data: any): FileRateLimitRule {
        data = typeof data === 'object' ? data : {};
        let result = new FileRateLimitRule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.clientWhitelist)) {
            data["clientWhitelist"] = [];
            for (let item of this.clientWhitelist)
                data["clientWhitelist"].push(item);
        }
        data["enableRateLimiting"] = this.enableRateLimiting;
        data["period"] = this.period;
        data["periodTimespan"] = this.periodTimespan;
        data["limit"] = this.limit;
        return data;
    }
}

export interface IFileRateLimitRule {
    clientWhitelist?: string[] | undefined;
    enableRateLimiting?: boolean;
    period?: string | undefined;
    periodTimespan?: number;
    limit?: number;
}

export class FileRoute implements IFileRoute {
    addClaimsToRequest?: { [key: string]: string; } | undefined;
    addHeadersToRequest?: { [key: string]: string; } | undefined;
    addQueriesToRequest?: { [key: string]: string; } | undefined;
    authenticationOptions?: FileAuthenticationOptions;
    changeDownstreamPathTemplate?: { [key: string]: string; } | undefined;
    dangerousAcceptAnyServerCertificateValidator?: boolean;
    delegatingHandlers?: string[] | undefined;
    downstreamHeaderTransform?: { [key: string]: string; } | undefined;
    downstreamHostAndPorts?: FileHostAndPort[] | undefined;
    downstreamHttpMethod?: string | undefined;
    downstreamHttpVersion?: string | undefined;
    downstreamHttpVersionPolicy?: string | undefined;
    downstreamPathTemplate?: string | undefined;
    downstreamScheme?: string | undefined;
    fileCacheOptions?: FileCacheOptions;
    httpHandlerOptions?: FileHttpHandlerOptions;
    key?: string | undefined;
    loadBalancerOptions?: FileLoadBalancerOptions;
    metadata?: { [key: string]: string; } | undefined;
    priority?: number;
    qoSOptions?: FileQoSOptions;
    rateLimitOptions?: FileRateLimitRule;
    requestIdKey?: string | undefined;
    routeClaimsRequirement?: { [key: string]: string; } | undefined;
    routeIsCaseSensitive?: boolean;
    securityOptions?: FileSecurityOptions;
    serviceName?: string | undefined;
    serviceNamespace?: string | undefined;
    timeout?: number;
    upstreamHeaderTransform?: { [key: string]: string; } | undefined;
    upstreamHost?: string | undefined;
    upstreamHttpMethod?: string[] | undefined;
    upstreamPathTemplate?: string | undefined;
    upstreamHeaderTemplates?: { [key: string]: string; } | undefined;

    constructor(data?: IFileRoute) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["addClaimsToRequest"]) {
                this.addClaimsToRequest = {} as any;
                for (let key in _data["addClaimsToRequest"]) {
                    if (_data["addClaimsToRequest"].hasOwnProperty(key))
                        (<any>this.addClaimsToRequest)![key] = _data["addClaimsToRequest"][key];
                }
            }
            if (_data["addHeadersToRequest"]) {
                this.addHeadersToRequest = {} as any;
                for (let key in _data["addHeadersToRequest"]) {
                    if (_data["addHeadersToRequest"].hasOwnProperty(key))
                        (<any>this.addHeadersToRequest)![key] = _data["addHeadersToRequest"][key];
                }
            }
            if (_data["addQueriesToRequest"]) {
                this.addQueriesToRequest = {} as any;
                for (let key in _data["addQueriesToRequest"]) {
                    if (_data["addQueriesToRequest"].hasOwnProperty(key))
                        (<any>this.addQueriesToRequest)![key] = _data["addQueriesToRequest"][key];
                }
            }
            this.authenticationOptions = _data["authenticationOptions"] ? FileAuthenticationOptions.fromJS(_data["authenticationOptions"]) : <any>undefined;
            if (_data["changeDownstreamPathTemplate"]) {
                this.changeDownstreamPathTemplate = {} as any;
                for (let key in _data["changeDownstreamPathTemplate"]) {
                    if (_data["changeDownstreamPathTemplate"].hasOwnProperty(key))
                        (<any>this.changeDownstreamPathTemplate)![key] = _data["changeDownstreamPathTemplate"][key];
                }
            }
            this.dangerousAcceptAnyServerCertificateValidator = _data["dangerousAcceptAnyServerCertificateValidator"];
            if (Array.isArray(_data["delegatingHandlers"])) {
                this.delegatingHandlers = [] as any;
                for (let item of _data["delegatingHandlers"])
                    this.delegatingHandlers!.push(item);
            }
            if (_data["downstreamHeaderTransform"]) {
                this.downstreamHeaderTransform = {} as any;
                for (let key in _data["downstreamHeaderTransform"]) {
                    if (_data["downstreamHeaderTransform"].hasOwnProperty(key))
                        (<any>this.downstreamHeaderTransform)![key] = _data["downstreamHeaderTransform"][key];
                }
            }
            if (Array.isArray(_data["downstreamHostAndPorts"])) {
                this.downstreamHostAndPorts = [] as any;
                for (let item of _data["downstreamHostAndPorts"])
                    this.downstreamHostAndPorts!.push(FileHostAndPort.fromJS(item));
            }
            this.downstreamHttpMethod = _data["downstreamHttpMethod"];
            this.downstreamHttpVersion = _data["downstreamHttpVersion"];
            this.downstreamHttpVersionPolicy = _data["downstreamHttpVersionPolicy"];
            this.downstreamPathTemplate = _data["downstreamPathTemplate"];
            this.downstreamScheme = _data["downstreamScheme"];
            this.fileCacheOptions = _data["fileCacheOptions"] ? FileCacheOptions.fromJS(_data["fileCacheOptions"]) : <any>undefined;
            this.httpHandlerOptions = _data["httpHandlerOptions"] ? FileHttpHandlerOptions.fromJS(_data["httpHandlerOptions"]) : <any>undefined;
            this.key = _data["key"];
            this.loadBalancerOptions = _data["loadBalancerOptions"] ? FileLoadBalancerOptions.fromJS(_data["loadBalancerOptions"]) : <any>undefined;
            if (_data["metadata"]) {
                this.metadata = {} as any;
                for (let key in _data["metadata"]) {
                    if (_data["metadata"].hasOwnProperty(key))
                        (<any>this.metadata)![key] = _data["metadata"][key];
                }
            }
            this.priority = _data["priority"];
            this.qoSOptions = _data["qoSOptions"] ? FileQoSOptions.fromJS(_data["qoSOptions"]) : <any>undefined;
            this.rateLimitOptions = _data["rateLimitOptions"] ? FileRateLimitRule.fromJS(_data["rateLimitOptions"]) : <any>undefined;
            this.requestIdKey = _data["requestIdKey"];
            if (_data["routeClaimsRequirement"]) {
                this.routeClaimsRequirement = {} as any;
                for (let key in _data["routeClaimsRequirement"]) {
                    if (_data["routeClaimsRequirement"].hasOwnProperty(key))
                        (<any>this.routeClaimsRequirement)![key] = _data["routeClaimsRequirement"][key];
                }
            }
            this.routeIsCaseSensitive = _data["routeIsCaseSensitive"];
            this.securityOptions = _data["securityOptions"] ? FileSecurityOptions.fromJS(_data["securityOptions"]) : <any>undefined;
            this.serviceName = _data["serviceName"];
            this.serviceNamespace = _data["serviceNamespace"];
            this.timeout = _data["timeout"];
            if (_data["upstreamHeaderTransform"]) {
                this.upstreamHeaderTransform = {} as any;
                for (let key in _data["upstreamHeaderTransform"]) {
                    if (_data["upstreamHeaderTransform"].hasOwnProperty(key))
                        (<any>this.upstreamHeaderTransform)![key] = _data["upstreamHeaderTransform"][key];
                }
            }
            this.upstreamHost = _data["upstreamHost"];
            if (Array.isArray(_data["upstreamHttpMethod"])) {
                this.upstreamHttpMethod = [] as any;
                for (let item of _data["upstreamHttpMethod"])
                    this.upstreamHttpMethod!.push(item);
            }
            this.upstreamPathTemplate = _data["upstreamPathTemplate"];
            if (_data["upstreamHeaderTemplates"]) {
                this.upstreamHeaderTemplates = {} as any;
                for (let key in _data["upstreamHeaderTemplates"]) {
                    if (_data["upstreamHeaderTemplates"].hasOwnProperty(key))
                        (<any>this.upstreamHeaderTemplates)![key] = _data["upstreamHeaderTemplates"][key];
                }
            }
        }
    }

    static fromJS(data: any): FileRoute {
        data = typeof data === 'object' ? data : {};
        let result = new FileRoute();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.addClaimsToRequest) {
            data["addClaimsToRequest"] = {};
            for (let key in this.addClaimsToRequest) {
                if (this.addClaimsToRequest.hasOwnProperty(key))
                    (<any>data["addClaimsToRequest"])[key] = (<any>this.addClaimsToRequest)[key];
            }
        }
        if (this.addHeadersToRequest) {
            data["addHeadersToRequest"] = {};
            for (let key in this.addHeadersToRequest) {
                if (this.addHeadersToRequest.hasOwnProperty(key))
                    (<any>data["addHeadersToRequest"])[key] = (<any>this.addHeadersToRequest)[key];
            }
        }
        if (this.addQueriesToRequest) {
            data["addQueriesToRequest"] = {};
            for (let key in this.addQueriesToRequest) {
                if (this.addQueriesToRequest.hasOwnProperty(key))
                    (<any>data["addQueriesToRequest"])[key] = (<any>this.addQueriesToRequest)[key];
            }
        }
        data["authenticationOptions"] = this.authenticationOptions ? this.authenticationOptions.toJSON() : <any>undefined;
        if (this.changeDownstreamPathTemplate) {
            data["changeDownstreamPathTemplate"] = {};
            for (let key in this.changeDownstreamPathTemplate) {
                if (this.changeDownstreamPathTemplate.hasOwnProperty(key))
                    (<any>data["changeDownstreamPathTemplate"])[key] = (<any>this.changeDownstreamPathTemplate)[key];
            }
        }
        data["dangerousAcceptAnyServerCertificateValidator"] = this.dangerousAcceptAnyServerCertificateValidator;
        if (Array.isArray(this.delegatingHandlers)) {
            data["delegatingHandlers"] = [];
            for (let item of this.delegatingHandlers)
                data["delegatingHandlers"].push(item);
        }
        if (this.downstreamHeaderTransform) {
            data["downstreamHeaderTransform"] = {};
            for (let key in this.downstreamHeaderTransform) {
                if (this.downstreamHeaderTransform.hasOwnProperty(key))
                    (<any>data["downstreamHeaderTransform"])[key] = (<any>this.downstreamHeaderTransform)[key];
            }
        }
        if (Array.isArray(this.downstreamHostAndPorts)) {
            data["downstreamHostAndPorts"] = [];
            for (let item of this.downstreamHostAndPorts)
                data["downstreamHostAndPorts"].push(item.toJSON());
        }
        data["downstreamHttpMethod"] = this.downstreamHttpMethod;
        data["downstreamHttpVersion"] = this.downstreamHttpVersion;
        data["downstreamHttpVersionPolicy"] = this.downstreamHttpVersionPolicy;
        data["downstreamPathTemplate"] = this.downstreamPathTemplate;
        data["downstreamScheme"] = this.downstreamScheme;
        data["fileCacheOptions"] = this.fileCacheOptions ? this.fileCacheOptions.toJSON() : <any>undefined;
        data["httpHandlerOptions"] = this.httpHandlerOptions ? this.httpHandlerOptions.toJSON() : <any>undefined;
        data["key"] = this.key;
        data["loadBalancerOptions"] = this.loadBalancerOptions ? this.loadBalancerOptions.toJSON() : <any>undefined;
        if (this.metadata) {
            data["metadata"] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key))
                    (<any>data["metadata"])[key] = (<any>this.metadata)[key];
            }
        }
        data["priority"] = this.priority;
        data["qoSOptions"] = this.qoSOptions ? this.qoSOptions.toJSON() : <any>undefined;
        data["rateLimitOptions"] = this.rateLimitOptions ? this.rateLimitOptions.toJSON() : <any>undefined;
        data["requestIdKey"] = this.requestIdKey;
        if (this.routeClaimsRequirement) {
            data["routeClaimsRequirement"] = {};
            for (let key in this.routeClaimsRequirement) {
                if (this.routeClaimsRequirement.hasOwnProperty(key))
                    (<any>data["routeClaimsRequirement"])[key] = (<any>this.routeClaimsRequirement)[key];
            }
        }
        data["routeIsCaseSensitive"] = this.routeIsCaseSensitive;
        data["securityOptions"] = this.securityOptions ? this.securityOptions.toJSON() : <any>undefined;
        data["serviceName"] = this.serviceName;
        data["serviceNamespace"] = this.serviceNamespace;
        data["timeout"] = this.timeout;
        if (this.upstreamHeaderTransform) {
            data["upstreamHeaderTransform"] = {};
            for (let key in this.upstreamHeaderTransform) {
                if (this.upstreamHeaderTransform.hasOwnProperty(key))
                    (<any>data["upstreamHeaderTransform"])[key] = (<any>this.upstreamHeaderTransform)[key];
            }
        }
        data["upstreamHost"] = this.upstreamHost;
        if (Array.isArray(this.upstreamHttpMethod)) {
            data["upstreamHttpMethod"] = [];
            for (let item of this.upstreamHttpMethod)
                data["upstreamHttpMethod"].push(item);
        }
        data["upstreamPathTemplate"] = this.upstreamPathTemplate;
        if (this.upstreamHeaderTemplates) {
            data["upstreamHeaderTemplates"] = {};
            for (let key in this.upstreamHeaderTemplates) {
                if (this.upstreamHeaderTemplates.hasOwnProperty(key))
                    (<any>data["upstreamHeaderTemplates"])[key] = (<any>this.upstreamHeaderTemplates)[key];
            }
        }
        return data;
    }
}

export interface IFileRoute {
    addClaimsToRequest?: { [key: string]: string; } | undefined;
    addHeadersToRequest?: { [key: string]: string; } | undefined;
    addQueriesToRequest?: { [key: string]: string; } | undefined;
    authenticationOptions?: FileAuthenticationOptions;
    changeDownstreamPathTemplate?: { [key: string]: string; } | undefined;
    dangerousAcceptAnyServerCertificateValidator?: boolean;
    delegatingHandlers?: string[] | undefined;
    downstreamHeaderTransform?: { [key: string]: string; } | undefined;
    downstreamHostAndPorts?: FileHostAndPort[] | undefined;
    downstreamHttpMethod?: string | undefined;
    downstreamHttpVersion?: string | undefined;
    downstreamHttpVersionPolicy?: string | undefined;
    downstreamPathTemplate?: string | undefined;
    downstreamScheme?: string | undefined;
    fileCacheOptions?: FileCacheOptions;
    httpHandlerOptions?: FileHttpHandlerOptions;
    key?: string | undefined;
    loadBalancerOptions?: FileLoadBalancerOptions;
    metadata?: { [key: string]: string; } | undefined;
    priority?: number;
    qoSOptions?: FileQoSOptions;
    rateLimitOptions?: FileRateLimitRule;
    requestIdKey?: string | undefined;
    routeClaimsRequirement?: { [key: string]: string; } | undefined;
    routeIsCaseSensitive?: boolean;
    securityOptions?: FileSecurityOptions;
    serviceName?: string | undefined;
    serviceNamespace?: string | undefined;
    timeout?: number;
    upstreamHeaderTransform?: { [key: string]: string; } | undefined;
    upstreamHost?: string | undefined;
    upstreamHttpMethod?: string[] | undefined;
    upstreamPathTemplate?: string | undefined;
    upstreamHeaderTemplates?: { [key: string]: string; } | undefined;
}

export class FileSecurityOptions implements IFileSecurityOptions {
    ipAllowedList?: string[] | undefined;
    ipBlockedList?: string[] | undefined;
    excludeAllowedFromBlocked?: boolean;

    constructor(data?: IFileSecurityOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["ipAllowedList"])) {
                this.ipAllowedList = [] as any;
                for (let item of _data["ipAllowedList"])
                    this.ipAllowedList!.push(item);
            }
            if (Array.isArray(_data["ipBlockedList"])) {
                this.ipBlockedList = [] as any;
                for (let item of _data["ipBlockedList"])
                    this.ipBlockedList!.push(item);
            }
            this.excludeAllowedFromBlocked = _data["excludeAllowedFromBlocked"];
        }
    }

    static fromJS(data: any): FileSecurityOptions {
        data = typeof data === 'object' ? data : {};
        let result = new FileSecurityOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ipAllowedList)) {
            data["ipAllowedList"] = [];
            for (let item of this.ipAllowedList)
                data["ipAllowedList"].push(item);
        }
        if (Array.isArray(this.ipBlockedList)) {
            data["ipBlockedList"] = [];
            for (let item of this.ipBlockedList)
                data["ipBlockedList"].push(item);
        }
        data["excludeAllowedFromBlocked"] = this.excludeAllowedFromBlocked;
        return data;
    }
}

export interface IFileSecurityOptions {
    ipAllowedList?: string[] | undefined;
    ipBlockedList?: string[] | undefined;
    excludeAllowedFromBlocked?: boolean;
}

export class FileServiceDiscoveryProvider implements IFileServiceDiscoveryProvider {
    scheme?: string | undefined;
    host?: string | undefined;
    port?: number;
    type?: string | undefined;
    token?: string | undefined;
    configurationKey?: string | undefined;
    pollingInterval?: number;
    namespace?: string | undefined;

    constructor(data?: IFileServiceDiscoveryProvider) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.scheme = _data["scheme"];
            this.host = _data["host"];
            this.port = _data["port"];
            this.type = _data["type"];
            this.token = _data["token"];
            this.configurationKey = _data["configurationKey"];
            this.pollingInterval = _data["pollingInterval"];
            this.namespace = _data["namespace"];
        }
    }

    static fromJS(data: any): FileServiceDiscoveryProvider {
        data = typeof data === 'object' ? data : {};
        let result = new FileServiceDiscoveryProvider();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["scheme"] = this.scheme;
        data["host"] = this.host;
        data["port"] = this.port;
        data["type"] = this.type;
        data["token"] = this.token;
        data["configurationKey"] = this.configurationKey;
        data["pollingInterval"] = this.pollingInterval;
        data["namespace"] = this.namespace;
        return data;
    }
}

export interface IFileServiceDiscoveryProvider {
    scheme?: string | undefined;
    host?: string | undefined;
    port?: number;
    type?: string | undefined;
    token?: string | undefined;
    configurationKey?: string | undefined;
    pollingInterval?: number;
    namespace?: string | undefined;
}

export class ResultAccessTokenDto implements IResultAccessTokenDto {
    access_token?: string | undefined;
    refresh_token?: string | undefined;
    expires_in?: number;
    token_type?: string | undefined;
    scope?: string | undefined;

    constructor(data?: IResultAccessTokenDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.access_token = _data["access_token"];
            this.refresh_token = _data["refresh_token"];
            this.expires_in = _data["expires_in"];
            this.token_type = _data["token_type"];
            this.scope = _data["scope"];
        }
    }

    static fromJS(data: any): ResultAccessTokenDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultAccessTokenDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["access_token"] = this.access_token;
        data["refresh_token"] = this.refresh_token;
        data["expires_in"] = this.expires_in;
        data["token_type"] = this.token_type;
        data["scope"] = this.scope;
        return data;
    }
}

export interface IResultAccessTokenDto {
    access_token?: string | undefined;
    refresh_token?: string | undefined;
    expires_in?: number;
    token_type?: string | undefined;
    scope?: string | undefined;
}

export class ResultAccessTokenDtoResultDto implements IResultAccessTokenDtoResultDto {
    isSuccess?: boolean | undefined;
    message?: string | undefined;
    status?: number | undefined;
    errors?: ErrorDto[] | undefined;
    referenceName?: string | undefined;
    description?: string | undefined;
    additionalInfo?: string | undefined;
    data?: ResultAccessTokenDto;

    constructor(data?: IResultAccessTokenDtoResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.message = _data["message"];
            this.status = _data["status"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDto.fromJS(item));
            }
            this.referenceName = _data["referenceName"];
            this.description = _data["description"];
            this.additionalInfo = _data["additionalInfo"];
            this.data = _data["data"] ? ResultAccessTokenDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ResultAccessTokenDtoResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultAccessTokenDtoResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["message"] = this.message;
        data["status"] = this.status;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        data["referenceName"] = this.referenceName;
        data["description"] = this.description;
        data["additionalInfo"] = this.additionalInfo;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IResultAccessTokenDtoResultDto {
    isSuccess?: boolean | undefined;
    message?: string | undefined;
    status?: number | undefined;
    errors?: ErrorDto[] | undefined;
    referenceName?: string | undefined;
    description?: string | undefined;
    additionalInfo?: string | undefined;
    data?: ResultAccessTokenDto;
}

export class Route implements IRoute {
    upstreamPathTemplate?: string | undefined;
    upstreamHttpMethod?: string[] | undefined;
    downstreamPathTemplate?: string | undefined;
    downstreamScheme?: string | undefined;
    downstreamHostAndPorts?: DownstreamHostAndPort[] | undefined;
    routeIsCaseSensitive?: boolean | undefined;
    swaggerKey?: string | undefined;
    key?: string | undefined;
    authenticationOptions?: AuthenticationOptions;

    constructor(data?: IRoute) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.upstreamPathTemplate = _data["upstreamPathTemplate"];
            if (Array.isArray(_data["upstreamHttpMethod"])) {
                this.upstreamHttpMethod = [] as any;
                for (let item of _data["upstreamHttpMethod"])
                    this.upstreamHttpMethod!.push(item);
            }
            this.downstreamPathTemplate = _data["downstreamPathTemplate"];
            this.downstreamScheme = _data["downstreamScheme"];
            if (Array.isArray(_data["downstreamHostAndPorts"])) {
                this.downstreamHostAndPorts = [] as any;
                for (let item of _data["downstreamHostAndPorts"])
                    this.downstreamHostAndPorts!.push(DownstreamHostAndPort.fromJS(item));
            }
            this.routeIsCaseSensitive = _data["routeIsCaseSensitive"];
            this.swaggerKey = _data["swaggerKey"];
            this.key = _data["key"];
            this.authenticationOptions = _data["authenticationOptions"] ? AuthenticationOptions.fromJS(_data["authenticationOptions"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Route {
        data = typeof data === 'object' ? data : {};
        let result = new Route();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["upstreamPathTemplate"] = this.upstreamPathTemplate;
        if (Array.isArray(this.upstreamHttpMethod)) {
            data["upstreamHttpMethod"] = [];
            for (let item of this.upstreamHttpMethod)
                data["upstreamHttpMethod"].push(item);
        }
        data["downstreamPathTemplate"] = this.downstreamPathTemplate;
        data["downstreamScheme"] = this.downstreamScheme;
        if (Array.isArray(this.downstreamHostAndPorts)) {
            data["downstreamHostAndPorts"] = [];
            for (let item of this.downstreamHostAndPorts)
                data["downstreamHostAndPorts"].push(item.toJSON());
        }
        data["routeIsCaseSensitive"] = this.routeIsCaseSensitive;
        data["swaggerKey"] = this.swaggerKey;
        data["key"] = this.key;
        data["authenticationOptions"] = this.authenticationOptions ? this.authenticationOptions.toJSON() : <any>undefined;
        return data;
    }
}

export interface IRoute {
    upstreamPathTemplate?: string | undefined;
    upstreamHttpMethod?: string[] | undefined;
    downstreamPathTemplate?: string | undefined;
    downstreamScheme?: string | undefined;
    downstreamHostAndPorts?: DownstreamHostAndPort[] | undefined;
    routeIsCaseSensitive?: boolean | undefined;
    swaggerKey?: string | undefined;
    key?: string | undefined;
    authenticationOptions?: AuthenticationOptions;
}

export class RouteConfigModel implements IRouteConfigModel {
    routes?: Route[] | undefined;

    constructor(data?: IRouteConfigModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["routes"])) {
                this.routes = [] as any;
                for (let item of _data["routes"])
                    this.routes!.push(Route.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RouteConfigModel {
        data = typeof data === 'object' ? data : {};
        let result = new RouteConfigModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.routes)) {
            data["routes"] = [];
            for (let item of this.routes)
                data["routes"].push(item.toJSON());
        }
        return data;
    }
}

export interface IRouteConfigModel {
    routes?: Route[] | undefined;
}

export class SwaggerEndpoint implements ISwaggerEndpoint {
    key?: string | undefined;
    transformByOcelotConfig?: boolean;
    config?: EndpointConfig[] | undefined;

    constructor(data?: ISwaggerEndpoint) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.transformByOcelotConfig = _data["transformByOcelotConfig"];
            if (Array.isArray(_data["config"])) {
                this.config = [] as any;
                for (let item of _data["config"])
                    this.config!.push(EndpointConfig.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SwaggerEndpoint {
        data = typeof data === 'object' ? data : {};
        let result = new SwaggerEndpoint();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["transformByOcelotConfig"] = this.transformByOcelotConfig;
        if (Array.isArray(this.config)) {
            data["config"] = [];
            for (let item of this.config)
                data["config"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISwaggerEndpoint {
    key?: string | undefined;
    transformByOcelotConfig?: boolean;
    config?: EndpointConfig[] | undefined;
}

export class SwaggerEndpointConfigAddModel implements ISwaggerEndpointConfigAddModel {
    routeConfig?: RouteConfigModel;
    swaggerEndpoint?: SwaggerEndpoint;

    constructor(data?: ISwaggerEndpointConfigAddModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.routeConfig = _data["routeConfig"] ? RouteConfigModel.fromJS(_data["routeConfig"]) : <any>undefined;
            this.swaggerEndpoint = _data["swaggerEndpoint"] ? SwaggerEndpoint.fromJS(_data["swaggerEndpoint"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SwaggerEndpointConfigAddModel {
        data = typeof data === 'object' ? data : {};
        let result = new SwaggerEndpointConfigAddModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["routeConfig"] = this.routeConfig ? this.routeConfig.toJSON() : <any>undefined;
        data["swaggerEndpoint"] = this.swaggerEndpoint ? this.swaggerEndpoint.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISwaggerEndpointConfigAddModel {
    routeConfig?: RouteConfigModel;
    swaggerEndpoint?: SwaggerEndpoint;
}

export class SwaggerEndpointConfigEditModel implements ISwaggerEndpointConfigEditModel {
    key?: string | undefined;
    routeConfig?: RouteConfigModel;
    swaggerEndpoint?: SwaggerEndpoint;

    constructor(data?: ISwaggerEndpointConfigEditModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.routeConfig = _data["routeConfig"] ? RouteConfigModel.fromJS(_data["routeConfig"]) : <any>undefined;
            this.swaggerEndpoint = _data["swaggerEndpoint"] ? SwaggerEndpoint.fromJS(_data["swaggerEndpoint"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SwaggerEndpointConfigEditModel {
        data = typeof data === 'object' ? data : {};
        let result = new SwaggerEndpointConfigEditModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["routeConfig"] = this.routeConfig ? this.routeConfig.toJSON() : <any>undefined;
        data["swaggerEndpoint"] = this.swaggerEndpoint ? this.swaggerEndpoint.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISwaggerEndpointConfigEditModel {
    key?: string | undefined;
    routeConfig?: RouteConfigModel;
    swaggerEndpoint?: SwaggerEndpoint;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}